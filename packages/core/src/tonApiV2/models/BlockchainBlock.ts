/* tslint:disable */
/* eslint-disable */
/**
 * REST api to TON blockchain explorer
 * Provide access to indexed TON blockchain
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: support@tonkeeper.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
import type { BlockValueFlow } from './BlockValueFlow';
import {
    BlockValueFlowFromJSON,
    BlockValueFlowFromJSONTyped,
    BlockValueFlowToJSON,
} from './BlockValueFlow';

/**
 * 
 * @export
 * @interface BlockchainBlock
 */
export interface BlockchainBlock {
    /**
     * 
     * @type {number}
     * @memberof BlockchainBlock
     */
    txQuantity: number;
    /**
     * 
     * @type {BlockValueFlow}
     * @memberof BlockchainBlock
     */
    valueFlow: BlockValueFlow;
    /**
     * 
     * @type {number}
     * @memberof BlockchainBlock
     */
    workchainId: number;
    /**
     * 
     * @type {string}
     * @memberof BlockchainBlock
     */
    shard: string;
    /**
     * 
     * @type {number}
     * @memberof BlockchainBlock
     */
    seqno: number;
    /**
     * 
     * @type {string}
     * @memberof BlockchainBlock
     */
    rootHash: string;
    /**
     * 
     * @type {string}
     * @memberof BlockchainBlock
     */
    fileHash: string;
    /**
     * 
     * @type {number}
     * @memberof BlockchainBlock
     */
    globalId: number;
    /**
     * 
     * @type {number}
     * @memberof BlockchainBlock
     */
    version: number;
    /**
     * 
     * @type {boolean}
     * @memberof BlockchainBlock
     */
    afterMerge: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BlockchainBlock
     */
    beforeSplit: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BlockchainBlock
     */
    afterSplit: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BlockchainBlock
     */
    wantSplit: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BlockchainBlock
     */
    wantMerge: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BlockchainBlock
     */
    keyBlock: boolean;
    /**
     * 
     * @type {number}
     * @memberof BlockchainBlock
     */
    genUtime: number;
    /**
     * 
     * @type {number}
     * @memberof BlockchainBlock
     */
    startLt: number;
    /**
     * 
     * @type {number}
     * @memberof BlockchainBlock
     */
    endLt: number;
    /**
     * 
     * @type {number}
     * @memberof BlockchainBlock
     */
    vertSeqno: number;
    /**
     * 
     * @type {number}
     * @memberof BlockchainBlock
     */
    genCatchainSeqno: number;
    /**
     * 
     * @type {number}
     * @memberof BlockchainBlock
     */
    minRefMcSeqno: number;
    /**
     * 
     * @type {number}
     * @memberof BlockchainBlock
     */
    prevKeyBlockSeqno: number;
    /**
     * 
     * @type {number}
     * @memberof BlockchainBlock
     */
    genSoftwareVersion?: number;
    /**
     * 
     * @type {number}
     * @memberof BlockchainBlock
     */
    genSoftwareCapabilities?: number;
    /**
     * 
     * @type {string}
     * @memberof BlockchainBlock
     */
    masterRef?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof BlockchainBlock
     */
    prevRefs: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof BlockchainBlock
     */
    inMsgDescrLength: number;
    /**
     * 
     * @type {number}
     * @memberof BlockchainBlock
     */
    outMsgDescrLength: number;
    /**
     * 
     * @type {string}
     * @memberof BlockchainBlock
     */
    randSeed: string;
    /**
     * 
     * @type {string}
     * @memberof BlockchainBlock
     */
    createdBy: string;
}

/**
 * Check if a given object implements the BlockchainBlock interface.
 */
export function instanceOfBlockchainBlock(value: object): boolean {
    let isInstance = true;
    isInstance = isInstance && "txQuantity" in value;
    isInstance = isInstance && "valueFlow" in value;
    isInstance = isInstance && "workchainId" in value;
    isInstance = isInstance && "shard" in value;
    isInstance = isInstance && "seqno" in value;
    isInstance = isInstance && "rootHash" in value;
    isInstance = isInstance && "fileHash" in value;
    isInstance = isInstance && "globalId" in value;
    isInstance = isInstance && "version" in value;
    isInstance = isInstance && "afterMerge" in value;
    isInstance = isInstance && "beforeSplit" in value;
    isInstance = isInstance && "afterSplit" in value;
    isInstance = isInstance && "wantSplit" in value;
    isInstance = isInstance && "wantMerge" in value;
    isInstance = isInstance && "keyBlock" in value;
    isInstance = isInstance && "genUtime" in value;
    isInstance = isInstance && "startLt" in value;
    isInstance = isInstance && "endLt" in value;
    isInstance = isInstance && "vertSeqno" in value;
    isInstance = isInstance && "genCatchainSeqno" in value;
    isInstance = isInstance && "minRefMcSeqno" in value;
    isInstance = isInstance && "prevKeyBlockSeqno" in value;
    isInstance = isInstance && "prevRefs" in value;
    isInstance = isInstance && "inMsgDescrLength" in value;
    isInstance = isInstance && "outMsgDescrLength" in value;
    isInstance = isInstance && "randSeed" in value;
    isInstance = isInstance && "createdBy" in value;

    return isInstance;
}

export function BlockchainBlockFromJSON(json: any): BlockchainBlock {
    return BlockchainBlockFromJSONTyped(json, false);
}

export function BlockchainBlockFromJSONTyped(json: any, ignoreDiscriminator: boolean): BlockchainBlock {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'txQuantity': json['tx_quantity'],
        'valueFlow': BlockValueFlowFromJSON(json['value_flow']),
        'workchainId': json['workchain_id'],
        'shard': json['shard'],
        'seqno': json['seqno'],
        'rootHash': json['root_hash'],
        'fileHash': json['file_hash'],
        'globalId': json['global_id'],
        'version': json['version'],
        'afterMerge': json['after_merge'],
        'beforeSplit': json['before_split'],
        'afterSplit': json['after_split'],
        'wantSplit': json['want_split'],
        'wantMerge': json['want_merge'],
        'keyBlock': json['key_block'],
        'genUtime': json['gen_utime'],
        'startLt': json['start_lt'],
        'endLt': json['end_lt'],
        'vertSeqno': json['vert_seqno'],
        'genCatchainSeqno': json['gen_catchain_seqno'],
        'minRefMcSeqno': json['min_ref_mc_seqno'],
        'prevKeyBlockSeqno': json['prev_key_block_seqno'],
        'genSoftwareVersion': !exists(json, 'gen_software_version') ? undefined : json['gen_software_version'],
        'genSoftwareCapabilities': !exists(json, 'gen_software_capabilities') ? undefined : json['gen_software_capabilities'],
        'masterRef': !exists(json, 'master_ref') ? undefined : json['master_ref'],
        'prevRefs': json['prev_refs'],
        'inMsgDescrLength': json['in_msg_descr_length'],
        'outMsgDescrLength': json['out_msg_descr_length'],
        'randSeed': json['rand_seed'],
        'createdBy': json['created_by'],
    };
}

export function BlockchainBlockToJSON(value?: BlockchainBlock | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'tx_quantity': value.txQuantity,
        'value_flow': BlockValueFlowToJSON(value.valueFlow),
        'workchain_id': value.workchainId,
        'shard': value.shard,
        'seqno': value.seqno,
        'root_hash': value.rootHash,
        'file_hash': value.fileHash,
        'global_id': value.globalId,
        'version': value.version,
        'after_merge': value.afterMerge,
        'before_split': value.beforeSplit,
        'after_split': value.afterSplit,
        'want_split': value.wantSplit,
        'want_merge': value.wantMerge,
        'key_block': value.keyBlock,
        'gen_utime': value.genUtime,
        'start_lt': value.startLt,
        'end_lt': value.endLt,
        'vert_seqno': value.vertSeqno,
        'gen_catchain_seqno': value.genCatchainSeqno,
        'min_ref_mc_seqno': value.minRefMcSeqno,
        'prev_key_block_seqno': value.prevKeyBlockSeqno,
        'gen_software_version': value.genSoftwareVersion,
        'gen_software_capabilities': value.genSoftwareCapabilities,
        'master_ref': value.masterRef,
        'prev_refs': value.prevRefs,
        'in_msg_descr_length': value.inMsgDescrLength,
        'out_msg_descr_length': value.outMsgDescrLength,
        'rand_seed': value.randSeed,
        'created_by': value.createdBy,
    };
}

